use crate::utils::file_tools::open_file;
use crate::utils::mutation::Mutation;
use crate::utils::types::MutByContig;
use anyhow::{Result, anyhow};
use log::info;
use rand::Rng;
use rand::seq::index::sample;
use std::io::Write;
use std::path::Path;

/// Converts a vector of 0s and 1s representing genotype to a standard
/// VCF genotype string.
///
/// # Arguments
///
/// * `genotype` - A vector of 0s and 1s representing genotype.
///
/// # Returns
///
/// Returns a string representing the genotype in VCF format.
fn genotype_to_string(genotype: Vec<usize>) -> Result<String> {
    let mut geno_string = String::new();
    for ploid in genotype {
        geno_string += &format!("{}/", ploid)
    }
    Ok(geno_string
        .strip_suffix("/")
        .ok_or_else(|| anyhow!("suffix not found"))?
        .to_string())
}

/// Processes variant data and writes output files.
///
/// # Arguments
///
/// * `mutations` - The generated mutations, indexed by contig
/// * `fasta_order` - A vector of contig names in the order they
///   appear in the reference FASTA.
/// * `ploidy` - The number of copies of each chromosome present in
///   the organism.
/// * `reference_path` - The path to the reference file that this VCF
///   is showing variants from.
/// * `output_file_prefix` - The directory path and filename prefix
///   for output files.
/// * `rng` - A random number generator for this run.
pub fn write_vcf<R: Rng>(
    mutations: &MutByContig,
    fasta_order: &Vec<String>,
    ploidy: usize,
    prob_mut_multiple: f64,
    reference_path: &Path,
    overwrite_output: bool,
    output_prefix: &Path,
    rng: &mut R,
) -> Result<()> {
    let filename = output_prefix.with_extension("vcf");
    info!("Writing {}", filename.display());

    let mut outfile = open_file(&filename, overwrite_output)?;

    let vcf_headers = [
        // File format and reference
        "##fileformat=VCFv4.1",
        &format!("##reference={}", reference_path.display()),
        "##Generated by crusty-neat",
        // INFO fields
        "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">",
        "##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">",
        "##INFO=<ID=VMX,Number=1,Type=String,Description=\"SNP is Missense in these Read Frames\">",
        "##INFO=<ID=VNX,Number=1,Type=String,Description=\"SNP is Nonsense in these Read Frames\">",
        "##INFO=<ID=VFX,Number=1,Type=String,Description=\"Indel Causes Frameshift\">",
        // ALT fields
        "##ALT=<ID=DEL,Description=\"Deletion\">",
        "##ALT=<ID=DUP,Description=\"Duplication\">",
        "##ALT=<ID=INS,Description=\"Insertion of novel sequence\">",
        "##ALT=<ID=INV,Description=\"Inversion\">",
        "##ALT=<ID=CNV,Description=\"Copy number variable region\">",
        "##ALT=<ID=TRANS,Description=\"Translocation\">",
        "##ALT=<ID=INV-TRANS,Description=\"Inverted translocation\">",
        // FORMAT fields
        "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">",
        // Column headers
        "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tNEAT_simulated_sample",
    ];

    // Write all lines
    for line in &vcf_headers {
        writeln!(outfile, "{}", line)?;
    }

    // insert mutations
    for contig in fasta_order {
        for mutation in &mutations[contig] {
            match mutation {
                Mutation::Snp {
                    pos,
                    ref_base,
                    alt_base,
                } => {
                    // If we're going to mutate more than one ploid (i.e. homozygous
                    // for diploid organisms), we must add it to the list.
                    let mut genotype: Vec<usize> = vec![0; ploidy];
                    // By default we'll assume heterozygous (only on one ploid).
                    let mut num_ploids: usize = 1;
                    let multiple_mut = rng.random_bool(prob_mut_multiple);
                    if multiple_mut && ploidy > 1 {
                        num_ploids = rng.random_range(1..=ploidy);
                    }
                    // for each ploid that has the mutation, change one random
                    // genotype to 1, indicating the mutation is on that copy.
                    for i in sample(rng, ploidy, num_ploids) {
                        genotype[i] = 1;
                    }
                    // Format the output line. Any fields without data will be
                    // a simple period. Quality is set to 37 for all these
                    // variants.
                    let line = format!(
                        "{}\t{}\t.\t{}\t{}\t37\tPASS\t.\tGT\t{}",
                        contig,
                        pos + 1, // check: seq starts at 1?
                        ref_base.to_base(),
                        alt_base.to_base(),
                        genotype_to_string(genotype)?,
                    );

                    writeln!(&mut outfile, "{}", line)?;
                }
                _ => {
                    return Err(anyhow!("Only SNPs are currently supported."));
                }
            }
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use tempdir::TempDir;

    use super::*;
    use crate::create_rng;
    use crate::utils::nucleotides::random_seq;
    use std::collections::HashMap;
    use std::path::PathBuf;

    #[test]
    fn test_genotype_to_string() -> Result<()> {
        let genotype = vec![0, 1, 0];
        assert_eq!(String::from("0/1/0"), genotype_to_string(genotype)?);
        Ok(())
    }

    #[test]
    fn test_write_vcf() -> Result<()> {
        let mut rng = create_rng(Some("Hello Cruel World"));
        let seq = random_seq(&mut rng, 100);
        let variants = HashMap::from([(
            "chr1".to_string(),
            vec![
                Mutation::new_snp(3, seq[3], seq[3].complement()).unwrap(),
                Mutation::new_snp(7, seq[7], seq[7].complement()).unwrap(),
            ],
        )]);
        let fasta_order = vec!["chr1".to_string()];
        let ploidy = 2;
        let prob_mut_multiple = 0.1;
        let reference_path = PathBuf::from("/fake/path/to/H1N1.fa");
        let tmp_dir = TempDir::new("crusty_neat")?;
        let output_file_prefix = tmp_dir.path().join("test");
        let overwrite_output = false;
        write_vcf(
            &variants,
            &fasta_order,
            ploidy,
            prob_mut_multiple,
            &reference_path,
            overwrite_output,
            &output_file_prefix,
            &mut rng,
        )?;
        let output_file = tmp_dir.path().join("test.vcf");
        assert!(output_file.exists());
        Ok(())
    }
}
