extern crate log;

use std::collections::HashMap;
use std::io;
use std::io::Write;
use std::fs::File;
use rand::Rng;
use rand::rngs::ThreadRng;
use rand::seq::IndexedRandom;
use utils::fasta_tools::num_to_char;

fn genotype_to_string(genotype: Vec<usize>) -> String {
    /*
    Converts a vector of 0s and 1s representing genotype to a standard
    vcf genotype string.
     */
    let mut geno_string = String::new();
    for ploid in genotype {
        geno_string += &format!("{}/", ploid.to_string())
    }
    geno_string.strip_suffix("/").unwrap().to_string()
}

pub fn write_vcf(
    variant_locations: &HashMap<String, Vec<(usize, u8, u8)>>,
    fasta_order: &Vec<String>,
    ploidy: usize,
    reference: &str,
    output_file_prefix: &str,
    mut rng: &mut ThreadRng,
) -> io::Result<()> {
    /*
    Takes:
        variant_locations: A map of contig names keyed to lists of variants in that contig
            consisting of a tuple of (position, alt base, ref base).
        fasta_order: A vector of contig names in the order of the reference fasta.
        ploidy: The number of copies of each chromosome present in the organism
        output_file_prefix: The path to the directory and the prefix to use for filenames
        rng: A random number generator for this run
    Result:
        Throws and error if there's a problem, or else returns nothing.
     */
    // ploid numbers are used to pick a number of ploids to mutate
    let ploid_numbers: Vec<usize> = (1..ploidy+1).collect();
    // set the filename of the output vcf
    let mut filename = format!("{}.vcf", output_file_prefix);
    let mut outfile = File::options().create_new(true).append(true).open(&mut filename)?;
    // add the vcf header
    writeln!(&mut outfile, "##fileformat=VCFv4.1")?;
    writeln!(&mut outfile, "##reference={}", reference)?;
    writeln!(&mut outfile, "##Generated by rusty-neat")?;
    writeln!(&mut outfile, "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">")?;
    writeln!(&mut outfile, "##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">")?;
    writeln!(&mut outfile, "##INFO=<ID=VMX,Number=1,Type=String, Description=\"SNP is Missense in these Read Frames\">")?;
    writeln!(&mut outfile, "##INFO=<ID=VNX,Number=1,Type=String, Description=\"SNP is Nonsense in these Read Frames\">")?;
    writeln!(&mut outfile, "##INFO=<ID=VFX,Number=1,Type=String,Description=\"Indel Causes Frameshift\">")?;
    writeln!(&mut outfile, "##ALT=<ID=DEL,Description=\"Deletion\">")?;
    writeln!(&mut outfile, "##ALT=<ID=DUP,Description=\"Duplication\">")?;
    writeln!(&mut outfile, "##ALT=<ID=INS,Description=\"Insertion of novel sequence\">")?;
    writeln!(&mut outfile, "##ALT=<ID=INV,Description=\"Inversion\">")?;
    writeln!(&mut outfile, "##ALT=<ID=CNV,Description=\"Copy number variable region\">")?;
    writeln!(&mut outfile, "##ALT=<ID=TRANS,Description=\"Translocation\">")?;
    writeln!(&mut outfile, "##ALT=<ID=INV-TRANS,Description=\"Inverted translocation\">")?;
    writeln!(&mut outfile, "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">")?;
    // Add a neat sample column
    writeln!(&mut outfile, "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tNEAT_simulated_sample")?;
    // insert mutations
    for contig in fasta_order {
        for mutation in &variant_locations[contig] {
            // If we're going to mutate more than one ploid (i.e. homozygous
            // for diploid organisms), we must add it to the list.
            let mut genotype: Vec<usize> = vec![0; ploidy];
            // We need to enumerate the index list for the genotype
            let ploid_index: Vec<usize> = (0..ploidy).collect();
            // By default we'll assume heterozygous (only on one ploid).
            let mut num_ploids: usize = 1;
            let is_multiploid = (&mut rng).gen_bool(0.001);
            if is_multiploid {
                num_ploids = *ploid_numbers.choose(&mut rng).unwrap();
            }
            for _ in 0..num_ploids {
                // for each ploid that has the mutation, change one random
                // genotype to 1, indicating the mutation is on that copy.
                genotype[*ploid_index.choose(&mut rng).unwrap()] = 1
            }
            // Format the output line. Any fields without data will be a simple period. Quality
            // is set to 37 for all these variants.
            let line = format!("{}\t{}\t.\t{}\t{}\t37\tPASS\t.\tGT\t{}",
                    contig,
                    mutation.0 + 1,
                    num_to_char(mutation.2),
                    num_to_char(mutation.1),
                    genotype_to_string(genotype),
                );

            writeln!(&mut outfile, "{}", line)?;
        }
    };
    Ok(())
}