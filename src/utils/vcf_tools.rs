extern crate log;

use super::file_tools::open_file;
use super::nucleotides::{nuc_to_base, Nuc};
use anyhow::{anyhow, Result};
use rand::seq::index::sample;
use rand::Rng;
use std::collections::HashMap;
use std::io::Write;

/// Converts a vector of 0s and 1s representing genotype to a standard
/// VCF genotype string.
///
/// # Arguments
///
/// * `genotype` - A vector of 0s and 1s representing genotype.
///
/// # Returns
///
/// Returns a string representing the genotype in VCF format.
fn genotype_to_string(genotype: Vec<usize>) -> Result<String> {
    let mut geno_string = String::new();
    for ploid in genotype {
        geno_string += &format!("{}/", ploid)
    }
    Ok(geno_string
        .strip_suffix("/")
        .ok_or_else(|| anyhow!("suffix not found"))?
        .to_string())
}

/// Processes variant data and writes output files.
///
/// # Arguments
///
/// * `variant_locations` - A map where keys are contig names, and
///   values are lists of variants in that contig. Each variant is
///   represented as a tuple of `(position, alt base, ref base)`.
/// * `fasta_order` - A vector of contig names in the order they
///   appear in the reference FASTA.
/// * `ploidy` - The number of copies of each chromosome present in
///   the organism.
/// * `reference_path` - The path to the reference file that this VCF
///   is showing variants from.
/// * `output_file_prefix` - The directory path and filename prefix
///   for output files.
/// * `rng` - A random number generator for this run.
///
/// # Returns
///
/// Returns `()` if successful. Throws an error if there is a problem.
pub fn write_vcf<R: Rng>(
    variant_locations: &HashMap<String, Vec<(usize, Nuc, Nuc)>>,
    fasta_order: &Vec<String>,
    ploidy: usize,
    reference_path: &str,
    overwrite_output: bool,
    output_file_prefix: &str,
    rng: &mut R,
) -> Result<()> {
    // set the filename of the output vcf
    let mut filename = format!("{}.vcf", output_file_prefix);
    let mut outfile = open_file(&mut filename, overwrite_output)?;
    // add the vcf header
    writeln!(&mut outfile, "##fileformat=VCFv4.1")?;
    writeln!(&mut outfile, "##reference={}", reference_path)?;
    writeln!(&mut outfile, "##Generated by crusty-neat")?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">"
    )?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">"
    )?;
    writeln!(&mut outfile, "##INFO=<ID=VMX,Number=1,Type=String, Description=\"SNP is Missense in these Read Frames\">")?;
    writeln!(&mut outfile, "##INFO=<ID=VNX,Number=1,Type=String, Description=\"SNP is Nonsense in these Read Frames\">")?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=VFX,Number=1,Type=String,Description=\"Indel Causes Frameshift\">"
    )?;
    writeln!(&mut outfile, "##ALT=<ID=DEL,Description=\"Deletion\">")?;
    writeln!(&mut outfile, "##ALT=<ID=DUP,Description=\"Duplication\">")?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=INS,Description=\"Insertion of novel sequence\">"
    )?;
    writeln!(&mut outfile, "##ALT=<ID=INV,Description=\"Inversion\">")?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=CNV,Description=\"Copy number variable region\">"
    )?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=TRANS,Description=\"Translocation\">"
    )?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=INV-TRANS,Description=\"Inverted translocation\">"
    )?;
    writeln!(
        &mut outfile,
        "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">"
    )?;
    // Add a neat sample column
    writeln!(
        &mut outfile,
        "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tNEAT_simulated_sample"
    )?;
    // insert mutations
    for contig in fasta_order {
        for mutation in &variant_locations[contig] {
            // If we're going to mutate more than one ploid (i.e. homozygous
            // for diploid organisms), we must add it to the list.
            let mut genotype: Vec<usize> = vec![0; ploidy];
            // By default we'll assume heterozygous (only on one ploid).
            let mut num_ploids: usize = 1;
            let is_multiploid = rng.random_bool(0.001);
            // If ploidy is only 1, then it doesn't matter
            if is_multiploid && ploidy > 1 {
                // Mod a random int by ploidy and add to 1 (since we
                // are modifying at least one copy). For example, with
                // a ploidy of 2 the right term will produce either 0
                // or 1, so we modify either 1 or 2 copies.
                num_ploids = rng.random_range(1..=ploidy);
            }
            // for each ploid that has the mutation, change one random
            // genotype to 1, indicating the mutation is on that copy.
            for i in sample(rng, ploidy, num_ploids) {
                genotype[i] = 1;
            }
            // Format the output line. Any fields without data will be
            // a simple period. Quality is set to 37 for all these
            // variants.
            let line = format!(
                "{}\t{}\t.\t{}\t{}\t37\tPASS\t.\tGT\t{}",
                contig,
                mutation.0 + 1,
                nuc_to_base(mutation.2),
                nuc_to_base(mutation.1),
                genotype_to_string(genotype)?,
            );

            writeln!(&mut outfile, "{}", line)?;
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::create_rng;
    use std::fs;
    use std::path::Path;

    #[test]
    fn test_genotype_to_string() -> Result<()> {
        let genotype = vec![0, 1, 0];
        assert_eq!(String::from("0/1/0"), genotype_to_string(genotype)?);
        Ok(())
    }

    #[test]
    fn test_write_vcf() -> Result<()> {
        let variant_locations = HashMap::from([(
            "chr1".to_string(),
            vec![(3, Nuc::A, Nuc::C), (7, Nuc::C, Nuc::G)],
        )]);
        let fasta_order = vec!["chr1".to_string()];
        let ploidy = 2;
        let reference_path = "/fake/path/to/H1N1.fa";
        let overwrite_output = false;
        let output_file_prefix = "test";
        let mut rng = create_rng(Some("Hello Cruel World"));
        write_vcf(
            &variant_locations,
            &fasta_order,
            ploidy,
            reference_path,
            overwrite_output,
            output_file_prefix,
            &mut rng,
        )?;
        assert!(Path::new("test.vcf").exists());
        fs::remove_file("test.vcf")?;
        Ok(())
    }
}
